{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"QCoro C++ Coroutine library for Qt Overview QCoro is a C++ library that provide set of tools to make use of C++20 coroutines in connection with certain asynchronous Qt actions. Take a look at the example below to see what an amazing thing coroutines are: QNetworkAccessManager networkAccessManager ; // co_await the reply - the coroutine is suspended until the QNetworkReply is finished. // While the coroutine is suspended, *the Qt event loop runs as usual*. const QNetworkReply * reply = co_await networkAccessManager . get ( url ); // Once the reply is finished, your code resumes here as if nothing amazing has just happened ;-) const auto data = reply -> readAll (); This library has only one class and one function that the user must be aware of: the class is QCoro::Task and must be used as a return type for any coroutine that co_await s a Qt type. The function is qCoro() and it provides coroutine-friendly wrappers for Qt types that have multiple asynchronous operations that the user may want to co_await (for example QProcess ). All the other code (basically everything in the QCoro::detail namespace) is here to provide the cogs and gears for the C++ coroutine machinery, making it possible to use Qt types with coroutines. The major benefit of using coroutines with Qt types is that it allows writing asynchronous code as if it were synchronous and, most importantly, while the coroutine is co_await ing, the Qt event loop runs as usual , meaning that your application remains responsive. This is a rather experimental library that I started working on to better understand coroutines in C++. After reading numerous articles and blog posts about coroutines, it still wasn't exactly clear to me how the whole thing works, so I started working on this library to get a better idea about coroutines. Coroutines Coroutines are regular functions, except that they can be suspended and resumed again. When a coroutine is suspended, it returns sort of a promise to the caller and the caller continues executing their code. At some point, the caller can use the newly introduced co_await keyword to wait for the returned promise to be fulfilled. When that happens, the caller is suspended and instead the coroutine is resumed. This allows writing asynchronous code as if it were synchronous, making it much easier to read and understand. That's not all that coroutines can do, you can read more about it in the 'Coroutines' section of this documentation. Supported Compilers This library requires a compiler that supports the Coroutine TS (obviously). Currently GCC and Clang are supported, MSVC should be possible too, but I haven't tried. All examples were tested with GCC 10 and Clang 11, although even slightly older versions should work. In both GCC and Clang, coroutine support must be explicitly enabled: GCC To enable coroutines support in GCC, add -fcoroutines to CXX_FLAGS . CMake: set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fcoroutines\") Clang In Clang coroutines are still considered experimental (unlike in GCC), so you cannot mix Clang and libstdc++. You must use Clang with libc++. Coroutines are enabled by adding -fcoroutines-ts to CMAKE_CXX_FLAGS . CMake: set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fcoroutines-ts -stdlib=libc++\") MSVC Currently not supported by QCoro, although MSVC does have full implementation of the Coroutines TS. It should be fairly easy to make QCoro work with MSVC, though. If you are willing to help, please od get in touch. Using QCoro Using QCoro is easy and only requires a few steps: 1) Get QCoro, build and install it git clone https://github.com/danvratil/qcoro.git cd qcoro mkdir build cd build cmake .. make # This will install QCoro into /usr/local/ prefix, change it by passing -DCMAKE_INSTALL_PREFIX=/usr # to the cmake command above. sudo make install 2) Add it to your CMake: find_package ( QCoro REQUIRED ) ... target_link_libraries ( your-target QCoro::QCoro ) 3) Use it in your code See the Reference section for detail. And that's it!","title":"Home"},{"location":"index.html#qcoro","text":"C++ Coroutine library for Qt","title":"QCoro"},{"location":"index.html#overview","text":"QCoro is a C++ library that provide set of tools to make use of C++20 coroutines in connection with certain asynchronous Qt actions. Take a look at the example below to see what an amazing thing coroutines are: QNetworkAccessManager networkAccessManager ; // co_await the reply - the coroutine is suspended until the QNetworkReply is finished. // While the coroutine is suspended, *the Qt event loop runs as usual*. const QNetworkReply * reply = co_await networkAccessManager . get ( url ); // Once the reply is finished, your code resumes here as if nothing amazing has just happened ;-) const auto data = reply -> readAll (); This library has only one class and one function that the user must be aware of: the class is QCoro::Task and must be used as a return type for any coroutine that co_await s a Qt type. The function is qCoro() and it provides coroutine-friendly wrappers for Qt types that have multiple asynchronous operations that the user may want to co_await (for example QProcess ). All the other code (basically everything in the QCoro::detail namespace) is here to provide the cogs and gears for the C++ coroutine machinery, making it possible to use Qt types with coroutines. The major benefit of using coroutines with Qt types is that it allows writing asynchronous code as if it were synchronous and, most importantly, while the coroutine is co_await ing, the Qt event loop runs as usual , meaning that your application remains responsive. This is a rather experimental library that I started working on to better understand coroutines in C++. After reading numerous articles and blog posts about coroutines, it still wasn't exactly clear to me how the whole thing works, so I started working on this library to get a better idea about coroutines.","title":"Overview"},{"location":"index.html#coroutines","text":"Coroutines are regular functions, except that they can be suspended and resumed again. When a coroutine is suspended, it returns sort of a promise to the caller and the caller continues executing their code. At some point, the caller can use the newly introduced co_await keyword to wait for the returned promise to be fulfilled. When that happens, the caller is suspended and instead the coroutine is resumed. This allows writing asynchronous code as if it were synchronous, making it much easier to read and understand. That's not all that coroutines can do, you can read more about it in the 'Coroutines' section of this documentation.","title":"Coroutines"},{"location":"index.html#supported-compilers","text":"This library requires a compiler that supports the Coroutine TS (obviously). Currently GCC and Clang are supported, MSVC should be possible too, but I haven't tried. All examples were tested with GCC 10 and Clang 11, although even slightly older versions should work. In both GCC and Clang, coroutine support must be explicitly enabled:","title":"Supported Compilers"},{"location":"index.html#gcc","text":"To enable coroutines support in GCC, add -fcoroutines to CXX_FLAGS . CMake: set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fcoroutines\")","title":"GCC"},{"location":"index.html#clang","text":"In Clang coroutines are still considered experimental (unlike in GCC), so you cannot mix Clang and libstdc++. You must use Clang with libc++. Coroutines are enabled by adding -fcoroutines-ts to CMAKE_CXX_FLAGS . CMake: set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fcoroutines-ts -stdlib=libc++\")","title":"Clang"},{"location":"index.html#msvc","text":"Currently not supported by QCoro, although MSVC does have full implementation of the Coroutines TS. It should be fairly easy to make QCoro work with MSVC, though. If you are willing to help, please od get in touch.","title":"MSVC"},{"location":"index.html#using-qcoro","text":"Using QCoro is easy and only requires a few steps: 1) Get QCoro, build and install it git clone https://github.com/danvratil/qcoro.git cd qcoro mkdir build cd build cmake .. make # This will install QCoro into /usr/local/ prefix, change it by passing -DCMAKE_INSTALL_PREFIX=/usr # to the cmake command above. sudo make install 2) Add it to your CMake: find_package ( QCoro REQUIRED ) ... target_link_libraries ( your-target QCoro::QCoro ) 3) Use it in your code See the Reference section for detail. And that's it!","title":"Using QCoro"},{"location":"install.html","text":"Get Started Install QCoro git clone https://github.com/danvratil/qcoro.git cd qcoro mkdir build cd build cmake .. make # This will install QCoro into /usr/local/ prefix, change it by passing -DCMAKE_INSTALL_PREFIX=/usr # to the cmake command above. sudo make install Add it to your CMake find_package ( QCoro REQUIRED ) # Set necessary compiler flags to enable coroutine support qcoro_enable_coroutines () ... target_link_libraries ( your-target QCoro::QCoro )","title":"Installation"},{"location":"install.html#get-started","text":"","title":"Get Started"},{"location":"install.html#install-qcoro","text":"git clone https://github.com/danvratil/qcoro.git cd qcoro mkdir build cd build cmake .. make # This will install QCoro into /usr/local/ prefix, change it by passing -DCMAKE_INSTALL_PREFIX=/usr # to the cmake command above. sudo make install","title":"Install QCoro"},{"location":"install.html#add-it-to-your-cmake","text":"find_package ( QCoro REQUIRED ) # Set necessary compiler flags to enable coroutine support qcoro_enable_coroutines () ... target_link_libraries ( your-target QCoro::QCoro )","title":"Add it to your CMake"},{"location":"about/license.html","text":"License QCoro is published under the MIT License MIT License Copyright (c) 2021 Daniel Vr\u00e1til dvratil@kde.org Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license.html#license","text":"QCoro is published under the MIT License","title":"License"},{"location":"about/license.html#mit-license","text":"Copyright (c) 2021 Daniel Vr\u00e1til dvratil@kde.org Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"coroutines/coawait.html","text":"co_await Explained The following paragraphs try to explain what is a coroutine and what co_await does in some simple way. I don't guarantee that any of this is factically correct. For more gritty (and correct) details, refer to the articles linked at the bottom of this document. Coroutines, simply put, are like normal functions except that they can be suspended (and resumed) in the middle. When a coroutine is suspended, execution returns to the function that has called the coroutine. If that function is also a coroutine and is waiting ( co_await ing) for the current coroutine to finish, then it is suspended as well and the execution returns to the function that has called that coroutine and so on, until a function that is an actual function (not a coroutine) is reached. In case of a regular Qt program, this \"top-level\" non-coroutine function will be the Qt's event loop - which means that while your coroutine, when called from the Qt event loop is suspended, the Qt event loop will continue to run until the coroutine is resumed again. Amongst many other things, this allows you to write asynchronous code as if it were synchronous without blocking the Qt event loop and making your application unresponsive. See the different examples in this document. Now let's look at the co_await keyword. This keyword tells the compiler that this is the point where the coroutine wants to be suspended, until the awaited object (the awaitable ) is ready. Anything type can be awaitable - either because it directly implements the interface needed by the C++ coroutine machinery, or because some external tools (like this library) are provided to wrap that type into something that implements the awaitable interface. The C++ coroutines introduce two additional keywords - co_return and co_yield : From an application programmer point of view, co_return behaves exactly the same as return , except that you cannot use the regular return in coroutines. There are some major differences under the hood, though, which is likely why there's a special keyword for returning from coroutines. co_yield allows a coroutine to produce a result without actually returning. Can be used for writing generators. Currently, this library has no support/usage of co_yield , so I won't go into more details here.","title":"co_await Explained"},{"location":"coroutines/coawait.html#co_await-explained","text":"The following paragraphs try to explain what is a coroutine and what co_await does in some simple way. I don't guarantee that any of this is factically correct. For more gritty (and correct) details, refer to the articles linked at the bottom of this document. Coroutines, simply put, are like normal functions except that they can be suspended (and resumed) in the middle. When a coroutine is suspended, execution returns to the function that has called the coroutine. If that function is also a coroutine and is waiting ( co_await ing) for the current coroutine to finish, then it is suspended as well and the execution returns to the function that has called that coroutine and so on, until a function that is an actual function (not a coroutine) is reached. In case of a regular Qt program, this \"top-level\" non-coroutine function will be the Qt's event loop - which means that while your coroutine, when called from the Qt event loop is suspended, the Qt event loop will continue to run until the coroutine is resumed again. Amongst many other things, this allows you to write asynchronous code as if it were synchronous without blocking the Qt event loop and making your application unresponsive. See the different examples in this document. Now let's look at the co_await keyword. This keyword tells the compiler that this is the point where the coroutine wants to be suspended, until the awaited object (the awaitable ) is ready. Anything type can be awaitable - either because it directly implements the interface needed by the C++ coroutine machinery, or because some external tools (like this library) are provided to wrap that type into something that implements the awaitable interface. The C++ coroutines introduce two additional keywords - co_return and co_yield : From an application programmer point of view, co_return behaves exactly the same as return , except that you cannot use the regular return in coroutines. There are some major differences under the hood, though, which is likely why there's a special keyword for returning from coroutines. co_yield allows a coroutine to produce a result without actually returning. Can be used for writing generators. Currently, this library has no support/usage of co_yield , so I won't go into more details here.","title":"co_await Explained"},{"location":"coroutines/qt-vs-coawait.html","text":"Qt vs. co_await One of the best examples where coroutines simplify your code is when dealing with asynchronous operations, like network operations. Let's see how a simple HTTP request would be handled in Qt using the signals/slots mechanism: void MyClass::fetchData () { auto * nam = new QNetworkAccessManager ( this ); auto * reply = nam -> get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); QObject :: connect ( reply , & QNetworkReply :: finished , [ reply , nam ]() { const auto data = reply -> readAll (); doSomethingWithData ( data ); reply -> deleteLater (); nam -> deleteLater (); }); } Now let's see how the code looks like if we use coroutines: QCoro :: Task <> MyClass :: fetchData () { QNetworkReply nam ; auto * reply = co_await nam . get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); const auto data = reply -> readAll (); reply -> deleteLater (); doSomethingWithData ( data ); } The magic here is the co_await keyword which has turned our method fetchData() into a coroutine and suspended its execution while the network request was running. When the request finishes, the coroutine is resumed from where it was suspended and continues. And the best part? While the coroutine is suspended, the Qt event loop runs as usual!","title":"Qt vs. co_await"},{"location":"coroutines/qt-vs-coawait.html#qt-vs-co_await","text":"One of the best examples where coroutines simplify your code is when dealing with asynchronous operations, like network operations. Let's see how a simple HTTP request would be handled in Qt using the signals/slots mechanism: void MyClass::fetchData () { auto * nam = new QNetworkAccessManager ( this ); auto * reply = nam -> get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); QObject :: connect ( reply , & QNetworkReply :: finished , [ reply , nam ]() { const auto data = reply -> readAll (); doSomethingWithData ( data ); reply -> deleteLater (); nam -> deleteLater (); }); } Now let's see how the code looks like if we use coroutines: QCoro :: Task <> MyClass :: fetchData () { QNetworkReply nam ; auto * reply = co_await nam . get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); const auto data = reply -> readAll (); reply -> deleteLater (); doSomethingWithData ( data ); } The magic here is the co_await keyword which has turned our method fetchData() into a coroutine and suspended its execution while the network request was running. When the request finishes, the coroutine is resumed from where it was suspended and continues. And the best part? While the coroutine is suspended, the Qt event loop runs as usual!","title":"Qt vs. co_await"},{"location":"coroutines/reading.html","text":"More reading This library is inspired by Lewis Bakers' cppcoro library, which also served as a guide to implementing the coroutine machinery, alongside his great series on C++ coroutines: Coroutine Theory Understanding Operator co_await Understanding the promise type Understanding Symmetric Transfer I can also recommend numerous articles about C++ coroutines by Raymond Chen on his blog OldNewThink .","title":"Further Reading"},{"location":"coroutines/reading.html#more-reading","text":"This library is inspired by Lewis Bakers' cppcoro library, which also served as a guide to implementing the coroutine machinery, alongside his great series on C++ coroutines: Coroutine Theory Understanding Operator co_await Understanding the promise type Understanding Symmetric Transfer I can also recommend numerous articles about C++ coroutines by Raymond Chen on his blog OldNewThink .","title":"More reading"},{"location":"reference/coro.html","text":"qCoro() Wrapping Qt Signals Awaitable qCoro ( QObject * , QtSignalPtr ); It is possible to co_await an emission of a Qt signal. Signal arguments are returned as a result of the co_await expression: MyDialog dialog ; ... const int result = co_await qCoro ( & dialog , & QDialog :: finished ); if ( result == QDialog :: Accepted ) { ... } If the signal has more than one argument, they are returned as a tuple: QProcess process ; ... const auto [ exitCode , exitStatus ] = co_await qCoro ( & process , & QProcess :: finished ); If the signal has no arguments, then the result of the co_await expression is void . Wrapping Qt Types QCoroType qCoro ( QtClass * ); QCoroType qCoro ( QtClass & ); This function is overloaded for all Qt types supported by this library. It accepts either a pointer or a reference to a Qt type, and returns a QCoro type that wraps the Qt type and provides coroutine-friendly API for the type. Some objects have only a single asynchronous event, so it makes sense to make them directly co_await able. An example is QTimer , where only one think can be co_await ed - the timer timeout. Thus with QCoro, it's possible to simply do this: QTimer timer ; ... co_await timer ; However, some Qt classes have multiple asynchronous operations that the user may want to co_await . For such types, simply co_await ing the class instance doesn't make sense since it's not clear what operation is being co_await ed. For those types, QCoro provides qCoro() function which returns a wrapper that provides coroutine-friendly versions of the asynchronous methods for the given type. Let's take QProcess as an example: one may want to co_await for the program to start or finish. Therefor, the type must be wrapped into qCoro() like this: QProcess process ; // Wait for the process to be started co_await qCoro ( process ). start (...); // The process is running now ... ... // Wait for it to finish co_await qCoro ( process ). finished (); // The process is no longer running ... qCoro() is simply overloaded for all the Qt types currently supported by the QCoro library. The function returns a wrapper object (e.g. QCoro::detail::QProcessWrapper ) which copies the QProcess API. It doesn't copy the entire API, only the bits that we want to make co_await able. When you call one of those metods (e.g. QProcessWrapper::start() ), it returns an awaitable type that calls QProcess::start() , suspends the coroutine and resumes it again when the wrapped QProcess object emits the started() signal. Normally you don't need to concern yourself with anything inside the QCoro::detail namespace, it's mentioned in the previous paragraph simply to explain how the wrapper works.","title":"QCoro::coro()"},{"location":"reference/coro.html#qcoro","text":"","title":"qCoro()"},{"location":"reference/coro.html#wrapping-qt-signals","text":"Awaitable qCoro ( QObject * , QtSignalPtr ); It is possible to co_await an emission of a Qt signal. Signal arguments are returned as a result of the co_await expression: MyDialog dialog ; ... const int result = co_await qCoro ( & dialog , & QDialog :: finished ); if ( result == QDialog :: Accepted ) { ... } If the signal has more than one argument, they are returned as a tuple: QProcess process ; ... const auto [ exitCode , exitStatus ] = co_await qCoro ( & process , & QProcess :: finished ); If the signal has no arguments, then the result of the co_await expression is void .","title":"Wrapping Qt Signals"},{"location":"reference/coro.html#wrapping-qt-types","text":"QCoroType qCoro ( QtClass * ); QCoroType qCoro ( QtClass & ); This function is overloaded for all Qt types supported by this library. It accepts either a pointer or a reference to a Qt type, and returns a QCoro type that wraps the Qt type and provides coroutine-friendly API for the type. Some objects have only a single asynchronous event, so it makes sense to make them directly co_await able. An example is QTimer , where only one think can be co_await ed - the timer timeout. Thus with QCoro, it's possible to simply do this: QTimer timer ; ... co_await timer ; However, some Qt classes have multiple asynchronous operations that the user may want to co_await . For such types, simply co_await ing the class instance doesn't make sense since it's not clear what operation is being co_await ed. For those types, QCoro provides qCoro() function which returns a wrapper that provides coroutine-friendly versions of the asynchronous methods for the given type. Let's take QProcess as an example: one may want to co_await for the program to start or finish. Therefor, the type must be wrapped into qCoro() like this: QProcess process ; // Wait for the process to be started co_await qCoro ( process ). start (...); // The process is running now ... ... // Wait for it to finish co_await qCoro ( process ). finished (); // The process is no longer running ... qCoro() is simply overloaded for all the Qt types currently supported by the QCoro library. The function returns a wrapper object (e.g. QCoro::detail::QProcessWrapper ) which copies the QProcess API. It doesn't copy the entire API, only the bits that we want to make co_await able. When you call one of those metods (e.g. QProcessWrapper::start() ), it returns an awaitable type that calls QProcess::start() , suspends the coroutine and resumes it again when the wrapped QProcess object emits the started() signal. Normally you don't need to concern yourself with anything inside the QCoro::detail namespace, it's mentioned in the previous paragraph simply to explain how the wrapper works.","title":"Wrapping Qt Types"},{"location":"reference/qabstractsocket.html","text":"QAbstractSocket class QCoroAbstractSocket : public QCoroIODevice ; QAbstractSocket is a base class for QTcpSocket and QUdpSocket and has some potentially asynchronous operations. In addition to reading and writing, which are provided by QIODevice baseclass and can be used with coroutines thanks to QCoro's QCoroIODevice . Those operations are connecting to and disconnecting from the server. Since QAbstractSocket doesn't provide the ability to co_await those operations, QCoro provides a wrapper calss QCoroAbstractSocket . To wrap a QAbstractSocket object into the QCoroAbstractSocket wrapper, use qCoro() : QCoroAbstractSocket qCoro ( QAbstractSocket & ); QCoroAbstractSocket qCoro ( QAbstractSocket * ); Same as QAbstractSocket is a subclass of QIODevice , QCoroAbstractSocket subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details. waitForConnected() Waits for the socket to connect or until it times out. Returns bool indicating whether connection has been established or whether the operation has timed out. The coroutine is not suspended if the socket is already connected. See documentation for QAbstractSocket::waitForConnected() for details. Awaitable auto QCoroAbstractSocket :: waitForConnected ( int timeout_msecs = 30'000 ); Awaitable auto QCoroAbstractSocket :: waitForConnected ( std :: chrono :: milliseconds timeout ); waitForDisconnected() Waits for the socket to disconnect from the server or until the operation times out. The coroutine is not suspended if the socket is already disconnected. See documentation for QAbstractSocket::waitForDisconnected() for details. Awaitable auto QCoroAbstractSocket :: waitForDisconnected ( timeout_msecs = 30'000 ); Awaitable auto QCoroAbstractSocket :: waitForDisconnected ( std :: chrono :: milliseconds timeout ); connectToHost() QCoroAbstractSocket provides an additional method called connectToHost() which is equivalent to calling QAbstractSocket::connectToHost() followed by QAbstractSocket::waitForConnected() . This operation is co_awaitable as well. See the documentation for [ QAbstractSocket::connectToHost() ][qtdoc-qabstractsocket-connectToHost] and QAbstractSocket::waitForConnected() for details. Awaitable auto QCoroAbstractSocket :: connectToHost ( const QHostAddress & address , quint16 port , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly ); Awaitable auto QCoroAbstractSocket :: connectToHost ( const QString & hostName , quint16 port , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly , QAbstractSocket :: NetworkLayerProtocol protocol = QAbstractSocket :: AnyIPProtocol ); Examples QCoro :: Task < QByteArray > requestDataFromServer ( const QString & hostName ) { QTcpSocket socket ; if ( ! co_await qCoro ( socket ). connectToHost ( hostName )) { qWarning () << \"Failed to connect to the server\" ; co_return QByteArray {}; } socket . write ( \"SEND ME DATA!\" ); QByteArray data ; while ( ! data . endsWith ( \" \\r\\n . \\r\\n \" )) { data += co_await qCoro ( socket ). readAll (); } co_return data ; }","title":"QAbstractSocket"},{"location":"reference/qabstractsocket.html#qabstractsocket","text":"class QCoroAbstractSocket : public QCoroIODevice ; QAbstractSocket is a base class for QTcpSocket and QUdpSocket and has some potentially asynchronous operations. In addition to reading and writing, which are provided by QIODevice baseclass and can be used with coroutines thanks to QCoro's QCoroIODevice . Those operations are connecting to and disconnecting from the server. Since QAbstractSocket doesn't provide the ability to co_await those operations, QCoro provides a wrapper calss QCoroAbstractSocket . To wrap a QAbstractSocket object into the QCoroAbstractSocket wrapper, use qCoro() : QCoroAbstractSocket qCoro ( QAbstractSocket & ); QCoroAbstractSocket qCoro ( QAbstractSocket * ); Same as QAbstractSocket is a subclass of QIODevice , QCoroAbstractSocket subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details.","title":"QAbstractSocket"},{"location":"reference/qabstractsocket.html#waitforconnected","text":"Waits for the socket to connect or until it times out. Returns bool indicating whether connection has been established or whether the operation has timed out. The coroutine is not suspended if the socket is already connected. See documentation for QAbstractSocket::waitForConnected() for details. Awaitable auto QCoroAbstractSocket :: waitForConnected ( int timeout_msecs = 30'000 ); Awaitable auto QCoroAbstractSocket :: waitForConnected ( std :: chrono :: milliseconds timeout );","title":"waitForConnected()"},{"location":"reference/qabstractsocket.html#waitfordisconnected","text":"Waits for the socket to disconnect from the server or until the operation times out. The coroutine is not suspended if the socket is already disconnected. See documentation for QAbstractSocket::waitForDisconnected() for details. Awaitable auto QCoroAbstractSocket :: waitForDisconnected ( timeout_msecs = 30'000 ); Awaitable auto QCoroAbstractSocket :: waitForDisconnected ( std :: chrono :: milliseconds timeout );","title":"waitForDisconnected()"},{"location":"reference/qabstractsocket.html#connecttohost","text":"QCoroAbstractSocket provides an additional method called connectToHost() which is equivalent to calling QAbstractSocket::connectToHost() followed by QAbstractSocket::waitForConnected() . This operation is co_awaitable as well. See the documentation for [ QAbstractSocket::connectToHost() ][qtdoc-qabstractsocket-connectToHost] and QAbstractSocket::waitForConnected() for details. Awaitable auto QCoroAbstractSocket :: connectToHost ( const QHostAddress & address , quint16 port , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly ); Awaitable auto QCoroAbstractSocket :: connectToHost ( const QString & hostName , quint16 port , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly , QAbstractSocket :: NetworkLayerProtocol protocol = QAbstractSocket :: AnyIPProtocol );","title":"connectToHost()"},{"location":"reference/qabstractsocket.html#examples","text":"QCoro :: Task < QByteArray > requestDataFromServer ( const QString & hostName ) { QTcpSocket socket ; if ( ! co_await qCoro ( socket ). connectToHost ( hostName )) { qWarning () << \"Failed to connect to the server\" ; co_return QByteArray {}; } socket . write ( \"SEND ME DATA!\" ); QByteArray data ; while ( ! data . endsWith ( \" \\r\\n . \\r\\n \" )) { data += co_await qCoro ( socket ). readAll (); } co_return data ; }","title":"Examples"},{"location":"reference/qdbuspendingcall.html","text":"QDBusPendingCall QDBusPendingCall callReturningQString = ... const QDBusReply<QString> reply = co_await callReturningQString; The QCoro frameworks allows co_await ing on QDBusPendingCall objects, which represent an asynchronous D-Bus call. The co-awaiting coroutine is suspended until the D-Bus call finishes. If the call has already finished, to coroutine will not be suspended. To make it work, include qcoro/dbus.h in your implementation. #include <qcoro/dbus.h> QCoro :: Task < QString > PlayerControl :: nextSong () { // Create a regular QDBusInterface representing the Spotify MPRIS interface QDBusInterface spotifyPlayer { QStringLiteral ( \"org.mpris.MediaPlayer2.spotify\" ), QStringLiteral ( \"/org/mpris/MediaPlayer2\" ), QStringLiteral ( \"org.mpris.MediaPlayer2.Player\" )}; // Call CanGoNext DBus method and co_await reply. During that the current coroutine is suspended. const QDBusReply < bool > canGoNext = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"CanGoNext\" )); // Response has arrived and coroutine is resumed. If the player can go to the next song, // do another async call to do so. if ( static_cast < bool > ( canGoNext )) { // co_await the call to finish, but throw away the result co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Next\" )); } // Finally, another async call to retrieve new track metadata. Once again, the coroutine // is suspended while we wait for the result. const QDBusReply < QVariantMap > metadata = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Metadata\" )); // Since this function uses co_await, it is in fact a coroutine, so it must use co_return in order // to return our result. By definition, the result of this function can be co_awaited by the caller. co_return static_cast < const QVariantMap &> ( metadata )[ QStringLiteral ( \"xesam:title\" )]. toString (); }","title":"QDBusPendingCall"},{"location":"reference/qdbuspendingcall.html#qdbuspendingcall","text":"QDBusPendingCall callReturningQString = ... const QDBusReply<QString> reply = co_await callReturningQString; The QCoro frameworks allows co_await ing on QDBusPendingCall objects, which represent an asynchronous D-Bus call. The co-awaiting coroutine is suspended until the D-Bus call finishes. If the call has already finished, to coroutine will not be suspended. To make it work, include qcoro/dbus.h in your implementation. #include <qcoro/dbus.h> QCoro :: Task < QString > PlayerControl :: nextSong () { // Create a regular QDBusInterface representing the Spotify MPRIS interface QDBusInterface spotifyPlayer { QStringLiteral ( \"org.mpris.MediaPlayer2.spotify\" ), QStringLiteral ( \"/org/mpris/MediaPlayer2\" ), QStringLiteral ( \"org.mpris.MediaPlayer2.Player\" )}; // Call CanGoNext DBus method and co_await reply. During that the current coroutine is suspended. const QDBusReply < bool > canGoNext = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"CanGoNext\" )); // Response has arrived and coroutine is resumed. If the player can go to the next song, // do another async call to do so. if ( static_cast < bool > ( canGoNext )) { // co_await the call to finish, but throw away the result co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Next\" )); } // Finally, another async call to retrieve new track metadata. Once again, the coroutine // is suspended while we wait for the result. const QDBusReply < QVariantMap > metadata = co_await spotifyPlayer . asyncCall ( QStringLiteral ( \"Metadata\" )); // Since this function uses co_await, it is in fact a coroutine, so it must use co_return in order // to return our result. By definition, the result of this function can be co_awaited by the caller. co_return static_cast < const QVariantMap &> ( metadata )[ QStringLiteral ( \"xesam:title\" )]. toString (); }","title":"QDBusPendingCall"},{"location":"reference/qfuture.html","text":"QFuture const QString result = co_await QtConcurrent :: run ( taskReturningQString ); The QCoro frameworks allows co_await ing on QFuture objects, which represent an asynchronously executed call. The co-awaiting coroutine is suspended until the QFuture is finished. If the QFuture object is already finished, the coroutine will not be suspended. To be able to use co_await with QFuture , include qcoro/future.h in your implementation. #include <qcoro/future.h> QCoro :: Task <> runTask () { // Starts a concurrent task and co_awaits on the returned QFuture. While the task is // running, the coroutine is suspended. const QString value = co_await QtConcurrent :: run ([]() { QString result ; ... // do some long-running computation ... return result ; }); // When the future has finished, the coroutine is resumed and the result of the // QFuture is returned and stored in `value`. // ... now do something with the value }","title":"QFuture"},{"location":"reference/qfuture.html#qfuture","text":"const QString result = co_await QtConcurrent :: run ( taskReturningQString ); The QCoro frameworks allows co_await ing on QFuture objects, which represent an asynchronously executed call. The co-awaiting coroutine is suspended until the QFuture is finished. If the QFuture object is already finished, the coroutine will not be suspended. To be able to use co_await with QFuture , include qcoro/future.h in your implementation. #include <qcoro/future.h> QCoro :: Task <> runTask () { // Starts a concurrent task and co_awaits on the returned QFuture. While the task is // running, the coroutine is suspended. const QString value = co_await QtConcurrent :: run ([]() { QString result ; ... // do some long-running computation ... return result ; }); // When the future has finished, the coroutine is resumed and the result of the // QFuture is returned and stored in `value`. // ... now do something with the value }","title":"QFuture"},{"location":"reference/qiodevice.html","text":"QIODevice class QCoroIODevice QIODevice has several different IO operations that can be waited on asynchronously. Since QIODevice itself doesn't provide the abaility to co_await those operations, QCoro provides a wrapper class called QCoroIODevice . To wrap a QIODevice into a QCoroIODevice , use qCoro() : QCoroIODevice qCoro ( QIODevice & ); QCoroIODevice qCoro ( QIODevice * ); Note that Qt provides several subclasses of QIODevice . QCoro provides coroutine-friendly wrappers for some of those types as well (e.g. for QLocalSocket ). This subclass can be passed to qCoro() function as well. Oftentimes the wrapper class will provide some additional features (like co_awaiting establishing connection etc.). You can check whether QCoro supports the QIODevice subclass by checking the list of supported Qt types. readAll() Waits until there are any data to be read from the device (similar to waiting until the device emits QIODevice::readyRead() signal) and then returns all data available in the buffer as a QByteArray . Doesn't suspend the coroutine if there are already data available in the QIODevice or if the QIODevice is not opened for reading. See documentation for QIODevice::readAll() for details. Awaitable auto QCoroIODevice :: readAll (); read() Waits until there are any data to be read from the device (similar to waiting until the device emits QIODevice::readyRead() signal) and then returns up to maxSize bytes as a QByteArray . Doesn't suspend the coroutine if there are already data available in the QIODevice or if the device is not opened for reading. See documentation for QIODevice::read() for details. Awaitable auto QCoroIODevice :: read ( qint64 maxSize = 0 ); readLine() Repeatedly waits for data to arrive until it encounters a newline character, end-of-data or until it reads maxSize bytes. Returns the resulting data as QByteArray . See documentation for QIODevice::readLine() for details. Awaitable auto QCoroIODevice :: readLine ( qint64 maxSize = 0 ) Examples const QByteArray data = co_await qCoro ( device ). readAll ();","title":"QIODevice"},{"location":"reference/qiodevice.html#qiodevice","text":"class QCoroIODevice QIODevice has several different IO operations that can be waited on asynchronously. Since QIODevice itself doesn't provide the abaility to co_await those operations, QCoro provides a wrapper class called QCoroIODevice . To wrap a QIODevice into a QCoroIODevice , use qCoro() : QCoroIODevice qCoro ( QIODevice & ); QCoroIODevice qCoro ( QIODevice * ); Note that Qt provides several subclasses of QIODevice . QCoro provides coroutine-friendly wrappers for some of those types as well (e.g. for QLocalSocket ). This subclass can be passed to qCoro() function as well. Oftentimes the wrapper class will provide some additional features (like co_awaiting establishing connection etc.). You can check whether QCoro supports the QIODevice subclass by checking the list of supported Qt types.","title":"QIODevice"},{"location":"reference/qiodevice.html#readall","text":"Waits until there are any data to be read from the device (similar to waiting until the device emits QIODevice::readyRead() signal) and then returns all data available in the buffer as a QByteArray . Doesn't suspend the coroutine if there are already data available in the QIODevice or if the QIODevice is not opened for reading. See documentation for QIODevice::readAll() for details. Awaitable auto QCoroIODevice :: readAll ();","title":"readAll()"},{"location":"reference/qiodevice.html#read","text":"Waits until there are any data to be read from the device (similar to waiting until the device emits QIODevice::readyRead() signal) and then returns up to maxSize bytes as a QByteArray . Doesn't suspend the coroutine if there are already data available in the QIODevice or if the device is not opened for reading. See documentation for QIODevice::read() for details. Awaitable auto QCoroIODevice :: read ( qint64 maxSize = 0 );","title":"read()"},{"location":"reference/qiodevice.html#readline","text":"Repeatedly waits for data to arrive until it encounters a newline character, end-of-data or until it reads maxSize bytes. Returns the resulting data as QByteArray . See documentation for QIODevice::readLine() for details. Awaitable auto QCoroIODevice :: readLine ( qint64 maxSize = 0 )","title":"readLine()"},{"location":"reference/qiodevice.html#examples","text":"const QByteArray data = co_await qCoro ( device ). readAll ();","title":"Examples"},{"location":"reference/qlocalsocket.html","text":"QLocalSocket class QCoroLocalSocket : public QCoroIODevice ; QLocalSocket has several potentially asynchronous operations in addition to reading and writing, which are provided by QIODevice baseclass and can be used with coroutines thanks to QCoro's QCoroIODevice . Those operations are connecting to and disconnecting from the server. Since QLocalSocket doesn't provide the ability to co_await those operations, QCoro provides a wrapper calss QCoroLocalSocket . To wrap a QLocalSocket object into the QCoroLocalSocket wrapper, use qCoro() : QCoroLocalSocket qCoro ( QLocalSocket & ); QCoroLocalSocket qCoro ( QLocalSocket * ); Same as QLocalSocket is a subclass of QIODevice , QCoroLocalSocket subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details. waitForConnected() Waits for the socket to connect or until it times out. Returns bool indicating whether connection has been established or whether the operation has timed out. The coroutine is not suspended if the socket is already connected. See documentation for QLocalSocket::waitForConnected() for details. Awaitable auto QCoroLocalSocket :: waitForConnected ( int timeout_msecs = 30'000 ); Awaitable auto QCoroLocalSocket :: waitForConnected ( std :: chrono :: milliseconds timeout ); waitForDisconnected() Waits for the socket to disconnect from the server or until the operation times out. The coroutine is not suspended if the socket is already disconnected. See documentation for QLocalSocket::waitForDisconnected() for details. Awaitable auto QCoroLocalSocket :: waitForDisconnected ( timeout_msecs = 30'000 ); Awaitable auto QCoroLocalSocket :: waitForDisconnected ( std :: chrono :: milliseconds timeout ); connectToServer() QCoroLocalSocket provides an additional method called connectToServer() which is equivalent to calling QLocalSocket::connectToServer() followed by QLocalSocket::waitForConnected() . This operation is co_awaitable as well. See the documentation for QLocalSocket::connectToServer() and QLocalSocket::waitForConnected() for details. Awaitable auto QCoroLocalSocket :: connectToServer ( QIODevice :: OpenMode openMode = QIODevice :: ReadOnly ); Awaitable auto QCoroLocalSocket :: connectToServer ( const QString & name , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly ); Examples QCoro :: Task < QByteArray > requestDataFromServer ( const QString & serverName ) { QLocalSocket socket ; if ( ! co_await qCoro ( socket ). connectToServer ( serverName )) { qWarning () << \"Failed to connect to the server\" ; co_return QByteArray {}; } socket . write ( \"SEND ME DATA!\" ); QByteArray data ; while ( ! data . endsWith ( \" \\r\\n . \\r\\n \" )) { data += co_await qCoro ( socket ). readAll (); } co_return data ; }","title":"QLocalSocket"},{"location":"reference/qlocalsocket.html#qlocalsocket","text":"class QCoroLocalSocket : public QCoroIODevice ; QLocalSocket has several potentially asynchronous operations in addition to reading and writing, which are provided by QIODevice baseclass and can be used with coroutines thanks to QCoro's QCoroIODevice . Those operations are connecting to and disconnecting from the server. Since QLocalSocket doesn't provide the ability to co_await those operations, QCoro provides a wrapper calss QCoroLocalSocket . To wrap a QLocalSocket object into the QCoroLocalSocket wrapper, use qCoro() : QCoroLocalSocket qCoro ( QLocalSocket & ); QCoroLocalSocket qCoro ( QLocalSocket * ); Same as QLocalSocket is a subclass of QIODevice , QCoroLocalSocket subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details.","title":"QLocalSocket"},{"location":"reference/qlocalsocket.html#waitforconnected","text":"Waits for the socket to connect or until it times out. Returns bool indicating whether connection has been established or whether the operation has timed out. The coroutine is not suspended if the socket is already connected. See documentation for QLocalSocket::waitForConnected() for details. Awaitable auto QCoroLocalSocket :: waitForConnected ( int timeout_msecs = 30'000 ); Awaitable auto QCoroLocalSocket :: waitForConnected ( std :: chrono :: milliseconds timeout );","title":"waitForConnected()"},{"location":"reference/qlocalsocket.html#waitfordisconnected","text":"Waits for the socket to disconnect from the server or until the operation times out. The coroutine is not suspended if the socket is already disconnected. See documentation for QLocalSocket::waitForDisconnected() for details. Awaitable auto QCoroLocalSocket :: waitForDisconnected ( timeout_msecs = 30'000 ); Awaitable auto QCoroLocalSocket :: waitForDisconnected ( std :: chrono :: milliseconds timeout );","title":"waitForDisconnected()"},{"location":"reference/qlocalsocket.html#connecttoserver","text":"QCoroLocalSocket provides an additional method called connectToServer() which is equivalent to calling QLocalSocket::connectToServer() followed by QLocalSocket::waitForConnected() . This operation is co_awaitable as well. See the documentation for QLocalSocket::connectToServer() and QLocalSocket::waitForConnected() for details. Awaitable auto QCoroLocalSocket :: connectToServer ( QIODevice :: OpenMode openMode = QIODevice :: ReadOnly ); Awaitable auto QCoroLocalSocket :: connectToServer ( const QString & name , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly );","title":"connectToServer()"},{"location":"reference/qlocalsocket.html#examples","text":"QCoro :: Task < QByteArray > requestDataFromServer ( const QString & serverName ) { QLocalSocket socket ; if ( ! co_await qCoro ( socket ). connectToServer ( serverName )) { qWarning () << \"Failed to connect to the server\" ; co_return QByteArray {}; } socket . write ( \"SEND ME DATA!\" ); QByteArray data ; while ( ! data . endsWith ( \" \\r\\n . \\r\\n \" )) { data += co_await qCoro ( socket ). readAll (); } co_return data ; }","title":"Examples"},{"location":"reference/qnetworkreply.html","text":"QNetworkReply class QCoroNetworkReply : public QCoroIODevice QNetworkReply has two asynchronous aspects: one is waiting for the reply to finish, and one for reading the response data as they arrive. QCoro supports both. QNetworkReply is a subclass of QIODevice , so you can leverage all the features of QCoroIODevice to asynchronously read data from the underlying QIODevice using coroutines. To wait for the reply to finish, one can simply co_await the reply object: QNetworkAccessManager nam ; auto * reply = co_await nam . get ( request ); The QCoro frameworks allows co_await ing on QNetworkReply objects. The co-awaiting coroutine is suspended, until QNetworkReply::finished() signal is emitted. To make it work, include qcoro/network.h in your implementation. #include <qcoro/network.h> QCoro :: Task <> MyClass :: fetchData () { // Creates QNetworkAccessManager on stack QNetworkAccessManager nam ; // Calls QNetworkAccessManager::get() and co_awaits on the returned QNetworkReply* // until it finishes. The current coroutine is suspended until that. auto * reply = co_await nam . get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); // When the reply finishes, the coroutine is resumed and we can access the reply content. const auto data = reply -> readAll (); // Raise your hand if you never forgot to delete a QNetworkReply... delete reply ; doSomethingWithData ( data ); // Extra bonus: the QNetworkAccessManager is destroyed automatically, since it's on stack. }","title":"QNetworkReply"},{"location":"reference/qnetworkreply.html#qnetworkreply","text":"class QCoroNetworkReply : public QCoroIODevice QNetworkReply has two asynchronous aspects: one is waiting for the reply to finish, and one for reading the response data as they arrive. QCoro supports both. QNetworkReply is a subclass of QIODevice , so you can leverage all the features of QCoroIODevice to asynchronously read data from the underlying QIODevice using coroutines. To wait for the reply to finish, one can simply co_await the reply object: QNetworkAccessManager nam ; auto * reply = co_await nam . get ( request ); The QCoro frameworks allows co_await ing on QNetworkReply objects. The co-awaiting coroutine is suspended, until QNetworkReply::finished() signal is emitted. To make it work, include qcoro/network.h in your implementation. #include <qcoro/network.h> QCoro :: Task <> MyClass :: fetchData () { // Creates QNetworkAccessManager on stack QNetworkAccessManager nam ; // Calls QNetworkAccessManager::get() and co_awaits on the returned QNetworkReply* // until it finishes. The current coroutine is suspended until that. auto * reply = co_await nam . get ( QUrl { QStringLiteral ( \"https://.../api/fetch\" )}); // When the reply finishes, the coroutine is resumed and we can access the reply content. const auto data = reply -> readAll (); // Raise your hand if you never forgot to delete a QNetworkReply... delete reply ; doSomethingWithData ( data ); // Extra bonus: the QNetworkAccessManager is destroyed automatically, since it's on stack. }","title":"QNetworkReply"},{"location":"reference/qprocess.html","text":"QProcess class QCoroProcess : public QCoroIODevice ; QProcess normally has two features to wait for asynchronously: the process to start and to finish. Since QProcess itself doesn't provide the ability to co_await those operations, QCoro provides a wrapper class QCoroProcess . To wrap a QProcess object into the QCoroProcess wrapper, use qCoro() : QCoroProcess qCoro ( QProcess & ); QCoroProcess qCoro ( QProcess * ); Same as QProcess is a subclass of QIODevice , QCoroProcess subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details. waitForStarted() Waits for the process to be started or until it times out. Returns bool indicating whether the process has started successfuly or timed out. See documentation for QProcess::waitForStarted() for details. Awaitable auto QCoroProcess :: waitForStarted ( int timeout = 30'000 ); Awaitable auto QCoroProcess :: waitForStarted ( std :: chrono :: milliseconds timeout ); waitForFinished() Waits for the process to finish or until it times out. Returns bool indicating whether the process has finished successfuly or timed out. See documentation for [ QProcess::waitForFinished() ][qtdoc-qprocess-waitForFinished] for details. Awaitable auto QCoroProcess :: waitForFinishedint timeout = 30'000 ); Awaitable auto QCoroProcess :: waitForFinished ( std :: chrono :: milliseconds timeout ); start() QCoroProcess provides an additional method called start() which is equivalent to calling QProcess::start() followed by QCoroProcess::waitForStarted() . This operation is co_awaitable as well. See the documentation for QProcess::start() and QProcess::waitForStarted() for details. Awaitable auto QCoroProcess :: start ( QIODevice :: OpenMode openMode ) = QIODevice :: ReadOnly ; Awaitable auto QCoroProcess :: start ( const QString & program , const QStringList & arguments , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly ); Examples QCoro :: Task < QStringList > listDir ( const QString & dirPath ) { QProcess process ; qDebug () << \"Starting ls...\" ; co_await process . start ( QStringLiteral ( \"/bin/ls\" ), { dirPath }); qDebug () << \"Ls started, reading directory...\" ; co_await process . waitForFinished (); qDebug () << \"Done\" ; return process . readAll (); }","title":"QProcess"},{"location":"reference/qprocess.html#qprocess","text":"class QCoroProcess : public QCoroIODevice ; QProcess normally has two features to wait for asynchronously: the process to start and to finish. Since QProcess itself doesn't provide the ability to co_await those operations, QCoro provides a wrapper class QCoroProcess . To wrap a QProcess object into the QCoroProcess wrapper, use qCoro() : QCoroProcess qCoro ( QProcess & ); QCoroProcess qCoro ( QProcess * ); Same as QProcess is a subclass of QIODevice , QCoroProcess subclasses QCoroIODevice , so it also provides the awaitable interface for selected QIODevice functions. See QCoroIODevice documentation for details.","title":"QProcess"},{"location":"reference/qprocess.html#waitforstarted","text":"Waits for the process to be started or until it times out. Returns bool indicating whether the process has started successfuly or timed out. See documentation for QProcess::waitForStarted() for details. Awaitable auto QCoroProcess :: waitForStarted ( int timeout = 30'000 ); Awaitable auto QCoroProcess :: waitForStarted ( std :: chrono :: milliseconds timeout );","title":"waitForStarted()"},{"location":"reference/qprocess.html#waitforfinished","text":"Waits for the process to finish or until it times out. Returns bool indicating whether the process has finished successfuly or timed out. See documentation for [ QProcess::waitForFinished() ][qtdoc-qprocess-waitForFinished] for details. Awaitable auto QCoroProcess :: waitForFinishedint timeout = 30'000 ); Awaitable auto QCoroProcess :: waitForFinished ( std :: chrono :: milliseconds timeout );","title":"waitForFinished()"},{"location":"reference/qprocess.html#start","text":"QCoroProcess provides an additional method called start() which is equivalent to calling QProcess::start() followed by QCoroProcess::waitForStarted() . This operation is co_awaitable as well. See the documentation for QProcess::start() and QProcess::waitForStarted() for details. Awaitable auto QCoroProcess :: start ( QIODevice :: OpenMode openMode ) = QIODevice :: ReadOnly ; Awaitable auto QCoroProcess :: start ( const QString & program , const QStringList & arguments , QIODevice :: OpenMode openMode = QIODevice :: ReadOnly );","title":"start()"},{"location":"reference/qprocess.html#examples","text":"QCoro :: Task < QStringList > listDir ( const QString & dirPath ) { QProcess process ; qDebug () << \"Starting ls...\" ; co_await process . start ( QStringLiteral ( \"/bin/ls\" ), { dirPath }); qDebug () << \"Ls started, reading directory...\" ; co_await process . waitForFinished (); qDebug () << \"Done\" ; return process . readAll (); }","title":"Examples"},{"location":"reference/qtcpserver.html","text":"QTcpServer class QCoroTcpServer : public QTcpServer ; QTcpServer really only has one asynchronous operation worth co_await ing, and that's waitForNewConnection() . Since QTcpServer doesn't provide the ability to co_await those operations, QCoro provides a wrapper class QCoroTcpServer . To wrap a QTcpServer object into the QCoroTcpServer wrapper, use qCoro() : QCoroTcpServer qCoro ( QTcpServer & ); QCoroTcpServer qCoro ( QTcpServer * ); waitForNewConnection() Waits until a new incoming connection is available or until it times out. Returns pointer to QTcpSocket or nullptr if the operation timed out or another error has occured. See documentation for QTcpServer::waitForNewConnection() for details. Awaitable auto QCoroTcpServer :: waitForNewConnection ( int timeout_msecs = 30'000 ); Awaitable auto QCoroTcpServer :: waitForNewConnection ( std :: chrono :: milliseconds timeout ); Examples QCoro :: Task <> runServer ( uint16_t port ) { QTcpServer server ; server . listen ( QHostAddress :: LocalHost , port ); while ( server . isListening ()) { auto * socket = co_await qCoro ( server ). waitForNewConnection ( 10 s ); if ( socket != nullptr ) { newClientConnection ( socket ); } } }","title":"QTcpServer"},{"location":"reference/qtcpserver.html#qtcpserver","text":"class QCoroTcpServer : public QTcpServer ; QTcpServer really only has one asynchronous operation worth co_await ing, and that's waitForNewConnection() . Since QTcpServer doesn't provide the ability to co_await those operations, QCoro provides a wrapper class QCoroTcpServer . To wrap a QTcpServer object into the QCoroTcpServer wrapper, use qCoro() : QCoroTcpServer qCoro ( QTcpServer & ); QCoroTcpServer qCoro ( QTcpServer * );","title":"QTcpServer"},{"location":"reference/qtcpserver.html#waitfornewconnection","text":"Waits until a new incoming connection is available or until it times out. Returns pointer to QTcpSocket or nullptr if the operation timed out or another error has occured. See documentation for QTcpServer::waitForNewConnection() for details. Awaitable auto QCoroTcpServer :: waitForNewConnection ( int timeout_msecs = 30'000 ); Awaitable auto QCoroTcpServer :: waitForNewConnection ( std :: chrono :: milliseconds timeout );","title":"waitForNewConnection()"},{"location":"reference/qtcpserver.html#examples","text":"QCoro :: Task <> runServer ( uint16_t port ) { QTcpServer server ; server . listen ( QHostAddress :: LocalHost , port ); while ( server . isListening ()) { auto * socket = co_await qCoro ( server ). waitForNewConnection ( 10 s ); if ( socket != nullptr ) { newClientConnection ( socket ); } } }","title":"Examples"},{"location":"reference/qtimer.html","text":"QTimer QTimer timer ; timer . start ( 1 s ); co_await timer ; The QCoro frameworks allows co_await ing on QTimer object. The co-awaiting coroutine is suspended, until the timer finishes, that is until QTimer::timeout() signal is emitted. The timer must be active. If the timer is not active (not started yet or already finished) the co_await expression will return immediately. To make it work, include qcoro/timer.h in your implementation. #include <qcoro/timer.h> #include <chrono> using namespace std :: chrono_literals ; QCoro :: Task <> MyClass :: pretendWork () { // Creates and starts a QTimer that will tick every second QTimer timer ; timer . setInterval ( 1 s ); timer . start (); for ( int i = 1 ; i <= 100 ; ++ i ) { // Wait for the timer to tick co_await timer ; // Update the progress bar value mProgressBar -> setValue ( i ); // And repeat... } // ... until the for loop finishes. }","title":"QTimer"},{"location":"reference/qtimer.html#qtimer","text":"QTimer timer ; timer . start ( 1 s ); co_await timer ; The QCoro frameworks allows co_await ing on QTimer object. The co-awaiting coroutine is suspended, until the timer finishes, that is until QTimer::timeout() signal is emitted. The timer must be active. If the timer is not active (not started yet or already finished) the co_await expression will return immediately. To make it work, include qcoro/timer.h in your implementation. #include <qcoro/timer.h> #include <chrono> using namespace std :: chrono_literals ; QCoro :: Task <> MyClass :: pretendWork () { // Creates and starts a QTimer that will tick every second QTimer timer ; timer . setInterval ( 1 s ); timer . start (); for ( int i = 1 ; i <= 100 ; ++ i ) { // Wait for the timer to tick co_await timer ; // Update the progress bar value mProgressBar -> setValue ( i ); // And repeat... } // ... until the for loop finishes. }","title":"QTimer"},{"location":"reference/task.html","text":"QCoro::Task template < typename T > class QCoro :: Task Any coroutine that wants to co_await one of the types supported by the QCoro library must have return type QCoro::Task<T> , where T is the type of the \"regular\" coroutine return value. There's no need by the user to interact with or construct QCoro::Task manually, the object is constructed automatically by the compiler before the user code is executed. To return a value from a coroutine, use co_return , which will store the result in the Task object and leave the coroutine. QCoro :: Task < QString > getUserName ( UserID userId ) { ... // Obtain a QString by co_awaiting another coroutine const QString result = co_await fetchUserNameFromDb ( userId ); ... // Return the QString from the coroutine as you would from a regular function, // just use `co_return` instead of `return` keyword. co_return result ; } To obtain the result of a coroutine that returns QCoro::Task<T> , the result must be co_await ed. When the coroutine co_return s a result, the result is stored in the Task object and the co_await ing coroutine is resumed. The result is obtained from the returned Task object and returned as a result of the co_await call. QCoro :: Task < void > getUserDetails ( UserID userId ) { ... const QString name = co_await getUserName ( userId ); ... } Exception Propagation When coroutines throws an unhandled exception, the exception is stored in the Task object and is re-thrown from the co_await call in the awaiting coroutine. Blocking wait Sometimes it's necessary to wait for a coroutine in a blocking manner - this is especially useful in tests where possibly no event loop is running. QCoro has QCoro::blockingWait() function which takes QCoro::Task<T> (that is, result of calling any QCoro-based coroutine) and blocks until the coroutine finishes. If the coroutine has a non-void return value, the value is returned from blockingWait(). QCoro :: Task < int > computeAnswer () { std :: this_thread :: sleep_for ( std :: chrono :: year { 7'500'000 }); co_return 42 ; } void nonCoroutineFunction () { // The following line will block as if computeAnswer were not a coroutine. const int answer = QCoro :: blockingWait ( computeAnswer ()); std :: cout << \"The answer is: \" << answer << std :: endl ; } Event loops The implementation internally uses a QEventLoop to wait for the coroutine to be completed. This means that a QCoreApplication instance must exist, although it does not need to be executed. Usual warnings about using a nested event loop apply here as well.","title":"QCoro::Task<T>"},{"location":"reference/task.html#qcorotask","text":"template < typename T > class QCoro :: Task Any coroutine that wants to co_await one of the types supported by the QCoro library must have return type QCoro::Task<T> , where T is the type of the \"regular\" coroutine return value. There's no need by the user to interact with or construct QCoro::Task manually, the object is constructed automatically by the compiler before the user code is executed. To return a value from a coroutine, use co_return , which will store the result in the Task object and leave the coroutine. QCoro :: Task < QString > getUserName ( UserID userId ) { ... // Obtain a QString by co_awaiting another coroutine const QString result = co_await fetchUserNameFromDb ( userId ); ... // Return the QString from the coroutine as you would from a regular function, // just use `co_return` instead of `return` keyword. co_return result ; } To obtain the result of a coroutine that returns QCoro::Task<T> , the result must be co_await ed. When the coroutine co_return s a result, the result is stored in the Task object and the co_await ing coroutine is resumed. The result is obtained from the returned Task object and returned as a result of the co_await call. QCoro :: Task < void > getUserDetails ( UserID userId ) { ... const QString name = co_await getUserName ( userId ); ... } Exception Propagation When coroutines throws an unhandled exception, the exception is stored in the Task object and is re-thrown from the co_await call in the awaiting coroutine.","title":"QCoro::Task"},{"location":"reference/task.html#blocking-wait","text":"Sometimes it's necessary to wait for a coroutine in a blocking manner - this is especially useful in tests where possibly no event loop is running. QCoro has QCoro::blockingWait() function which takes QCoro::Task<T> (that is, result of calling any QCoro-based coroutine) and blocks until the coroutine finishes. If the coroutine has a non-void return value, the value is returned from blockingWait(). QCoro :: Task < int > computeAnswer () { std :: this_thread :: sleep_for ( std :: chrono :: year { 7'500'000 }); co_return 42 ; } void nonCoroutineFunction () { // The following line will block as if computeAnswer were not a coroutine. const int answer = QCoro :: blockingWait ( computeAnswer ()); std :: cout << \"The answer is: \" << answer << std :: endl ; } Event loops The implementation internally uses a QEventLoop to wait for the coroutine to be completed. This means that a QCoreApplication instance must exist, although it does not need to be executed. Usual warnings about using a nested event loop apply here as well.","title":"Blocking wait"},{"location":"reference/using.html","text":"Using QCoro Using QCoro is super-easy. All you need to do is include a header that provides coroutine support for a type that you want to use with your coroutine and that's it. There's one extra thing that you have to do: once you use the co_await keyword in your function, the function facticaly becomes a coroutine. And coroutines must have a special return type. The type is sort of a promise type (not to confuse with std::promise ) that is returned to the caller when the coroutine is suspended. QCoro provides implementation of this \"special\" type in QCoro::Task . So in order to turn your function into a coroutine, you need to change the return type of your function from T to QCoro::Task<T> .","title":"Using QCoro"},{"location":"reference/using.html#using-qcoro","text":"Using QCoro is super-easy. All you need to do is include a header that provides coroutine support for a type that you want to use with your coroutine and that's it. There's one extra thing that you have to do: once you use the co_await keyword in your function, the function facticaly becomes a coroutine. And coroutines must have a special return type. The type is sort of a promise type (not to confuse with std::promise ) that is returned to the caller when the coroutine is suspended. QCoro provides implementation of this \"special\" type in QCoro::Task . So in order to turn your function into a coroutine, you need to change the return type of your function from T to QCoro::Task<T> .","title":"Using QCoro"}]}